1)Промисы -это способ организации асинхронного кода , где он имеет обещание будущих значении  операции . Ну, он еще имеет три разных состояния в которых он ждет выполнения  ,либо где то произошла ошибка , либо  выполнилась.
 (resolve ,reject,pending )
Результат будет доступен если промис успешно выполнился



2)async/await -Это специальные синтаксис для работы с промисами,

async- применяют при асинхронных функциях и он всегда возвращает промис и ставится перед функцией

await- ждет пока промис не выполнится  ее нельзя использовать в обычных функциях  он не может жить  без async


const getCoctails = async () => {
    const response = await fetch('https://www.thecocktaildb.com/api/json/v1/1/search.php?s=margarita');
    const {drinks} = await response.json();
    console.log(drinks)

getCoctails()



3)Контекст js-это значение переменной this внутри функции.
Каждый вызов функции имеет и область видимости, и переменную this, и контекст выполнения.

Область видимости определяет доступ к переменным при вызове функции и является уникальной для каждого вызова.
 Значение переменной this — это указание  на объект, который вызывает код в настоящий момент.
Контекст выполнения содержит и область видимости, и аргументы функции, и переменную this


const user = {
    name: 'John Smith',
    getName function() {
        console.log(this.name);
    }
};
user.getName()




4)Замыкание функции - замыкание даёт  доступ к внешней функции из внутренней функции замыкания создаются каждый раз при создании функции, во время её создания.Замыкание может запоминать и получать переменые и объекты своей внешней функции

const person()=> {
 let name = 'Peter';

 return function displayName() {
   console.log(name);
 };
}
let peter = person();
peter();




5)Зачем нужны стрелочные функции -стрелочные функции делают синтаксис короче, уменьшая время написания, чтения и тестирование кода, упрощая его.
У стрелочных функции нет собственного значения this  он всегда берет из окружения
У нее нет собственного контекста она ее наследует


let func1 = function(num1, num2)
 {return num1 * num2}-обычная функция


let func2 = (num1, num2) => num1 * num2;-стрелочная функция

